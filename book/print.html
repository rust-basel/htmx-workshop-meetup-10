<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js oranda-dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Meetup</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="oranda-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "oranda-dark" : "oranda-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('orandamdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('orandamdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('orandamdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('oranda-dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="axum/general.html"><strong aria-hidden="true">2.</strong> Axum</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="axum/axum.html"><strong aria-hidden="true">2.1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="axum/handlers.html"><strong aria-hidden="true">2.2.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="axum/extraction.html"><strong aria-hidden="true">2.3.</strong> Extraction</a></li><li class="chapter-item expanded "><a href="axum/state.html"><strong aria-hidden="true">2.4.</strong> State</a></li><li class="chapter-item expanded "><a href="axum/dependency_injection.html"><strong aria-hidden="true">2.5.</strong> Dependency Injection</a></li></ol></li><li class="chapter-item expanded "><a href="server_side_rendering/general.html"><strong aria-hidden="true">3.</strong> Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server_side_rendering/askama.html"><strong aria-hidden="true">3.1.</strong> Askama</a></li></ol></li><li class="chapter-item expanded "><a href="htmx/general.html"><strong aria-hidden="true">4.</strong> Htmx</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="htmx/htmx_intro.html"><strong aria-hidden="true">4.1.</strong> Why HTMX?</a></li><li class="chapter-item expanded "><a href="htmx/htmx_samples.html"><strong aria-hidden="true">4.2.</strong> HTMX samples</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-dark">Oranda Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-light">Oranda Light</button></li>

                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Meetup</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>We are going to introduce you <a href="https:///">HTMX</a> with the rust server framework <a href="https://github.com/tokio-rs/axum">axum</a>, which enables you to write reactive
web applications with ease without the need of javascript frameworks.</p>
<p>You can get a good grasp by looking at <a href="https://www.youtube.com/watch?v=r-GSGH2RxJs">fireship's 100s of HTMX video</a>.</p>
<h2 id="first-workshop-part"><a class="header" href="#first-workshop-part">First Workshop Part</a></h2>
<p>In this first part we will show you some basics with <a href="https://github.com/tokio-rs/axum">axum</a>,
rendering html with <a href="https://github.com/djc/askama">askama</a> and using <a href="https://htmx.org/">HTMX</a>.</p>
<p>In detail the first part consists of:</p>
<ul>
<li>Serving with <a href="https://github.com/tokio-rs/axum">axum</a>.</li>
<li>How to return html directly using <a href="https://github.com/djc/askama">askama</a> and how <a href="https://github.com/djc/askama">askama</a> works.</li>
<li>How to add <a href="https://htmx.org/">HTMX</a> to our html and how <a href="https://htmx.org/">HTMX</a> works with small examples.</li>
</ul>
<p>After you got the basics with server side rending and using htmx and having a good lunch,
we will hop on to the second part.</p>
<h2 id="second-workshop-part"><a class="header" href="#second-workshop-part">Second Workshop Part</a></h2>
<p>In the second part of the workshop you will build something yourself, without further guidance.
Of course we will help if you get stuck somewhere. Getting your hands dirty is the best way to learn.</p>
<p>You can mix and match server frameworks and rendering engines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general"><a class="header" href="#general">General</a></h1>
<p>There are plenty of web application frameworks out there.
Other big examples are <a href="https://github.com/seanmonstar/warp">warp</a>, <a href="https://actix.rs/">actix-web</a>, or <a href="https://rocket.rs/">rocket</a>.</p>
<p>For our workshop, we will use <a href="https://github.com/tokio-rs/axum">axum</a>, the web framework created by the folks from <a href="https://github.com/tokio-rs">tokio</a>, as we have the most knowledge about with it (If you get stuck and e.g. need help).</p>
<p>But you can translate features, that axum offers also to
the other frameworks in the one or the other way. In the end the only thing you need is a framework that is capable of sending html
over the wire and process incoming http requests, which all of the above frameworks are capable of.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="axum"><a class="header" href="#axum">Axum</a></h1>
<p><a href="https://github.com/tokio-rs/axum">Axum</a>, the web framework created by the folks from <a href="https://github.com/tokio-rs">tokio</a>.</p>
<p>What does axum feature, or set them apart from other frameworks:</p>
<ul>
<li>Macro free.</li>
<li>Parse requests using extractors. E.g. to extract JSON in a handler.</li>
<li>Has no own middleware - relies on integrating tower and tower-http and thus making it quite modular.</li>
</ul>
<p>So what will we show you, that you will need later on:</p>
<ul>
<li>How to write a handler in axum and return data as http response</li>
<li>How to extract a payload from an incoming request (Extractors)</li>
<li>How to add state to your application</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-add-handlers"><a class="header" href="#how-to-add-handlers">How to add Handlers</a></h1>
<p>Below is a small boilerplate in axum, which we examine, on how to write a handler in axum:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{response::IntoResponse, routing::get, Router};

async fn hello_world_handler() -&gt; impl IntoResponse {
    &quot;Hello World&quot;
}

#[tokio::main]
async fn main() {
    let router = Router::new().route(&quot;/&quot;, get(hello_world_handler));

    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:3000&quot;).await.unwrap();

    axum::serve(listener, router).await.unwrap();
}</code></pre></pre>
<p>As everything is asynchronous, we will need an asynchronous runtime, that executes our async functions. We will use <a href="https://tokio.rs/">tokio</a> for this (as axum is also from the same guys).</p>
<p>A handler in axum is just an ordinary asynchronous free function (<code>hello_world_handler</code>), that returns something, that implements <code>IntoResponse</code>. <code>IntoResponse</code> is a trait (Rust's interfaces) that tell the compiler, that this thing is convertible into a response.</p>
<p>To look what this means, you would have to look into the definition of <code>IntoResponse</code>. Fow now, it's sufficient to know, that it returns a payload and a status code.</p>
<p>For this example our handler returns a string literal, which will be converted in a http response of with payload of type <code>text/plain</code> with status code 200.</p>
<p>If you want to run the code, you can go to project in the snippets directory <code>snippets/axum/handlers</code> and run the project with
<code>cargo run</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-extraction-works-in-axum"><a class="header" href="#how-extraction-works-in-axum">How extraction works in axum</a></h1>
<p>In the chapter before you are only able to answer to client requests, that do not contain any payload. But there must be a way to send our small little server a payload.</p>
<p>For example:</p>
<ul>
<li>A server, that has some sort of user management, you want to add a new person to your database at some point in time.</li>
</ul>
<p>This is done by so called <em>extractors</em>. The incoming request is parsed, and if it for example contains a JSON payload, you have a JSON extractor, that parses that JSON.
After parsing you then can work on the data contained in the JSON.</p>
<p>There are also different extractors, which are ready to use. That would be for example:</p>
<ul>
<li>For queries: e.g. <code>/person?id=1234</code></li>
<li>For paths: e.g. <code>/person/1</code>, where the <code>1</code> would be extracted from the path</li>
<li>For forms: You can directly parse a form in a handler - that will come handy later for our workshop.</li>
</ul>
<p>You can also write your own extractor, if you need to. But this is out of scope for now (If you are interested, have a look at <a href="https://docs.rs/axum/latest/axum/extract/index.html">axum's docs</a>.</p>
<h2 id="extracting-json"><a class="header" href="#extracting-json">Extracting Json</a></h2>
<p>Below is a small snippet, where we explain, how for example a <em>JSON</em> extractor in axum looks like, that extracts the JSON payload from the incoming request.</p>
<pre><pre class="playground"><code class="language-rust">use axum::{response::IntoResponse, routing::post, Json, Router};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct PersonToAdd {
    name: String,
}

#[derive(Serialize)]
struct Person {
    id: i32,
    name: String,
}

async fn add_person_handler(Json(person_to_add): Json&lt;PersonToAdd&gt;) -&gt; impl IntoResponse {
    // let's just echo the incoming json
    // usually you would insert this person now into your database
    // ...

    let imaginary_id = 42;
    let person = Person {
        id: imaginary_id,
        name: person_to_add.name,
    };

    Json(person)
}

#[tokio::main]
async fn main() {
    let router = Router::new().route(&quot;/person&quot;, post(add_person_handler));

    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:3000&quot;).await.unwrap();

    axum::serve(listener, router).await.unwrap();
}</code></pre></pre>
<p>If you look closely, only the handler function and the route changed in our axum's <code>main</code> function.
To be detailed our new route
expects a JSON payload, that is deserializable into <code>PersonToAdd</code>.</p>
<p>To send it fitting paylod, we can use <em>curl</em>, as CLI tool, with which we can send http request.</p>
<pre><code class="language-sh">curl --header &quot;Content-Type: application/json&quot; --request POST --data '{&quot;name&quot;:&quot;Hans&quot;}' http://localhost:3000/person
</code></pre>
<p>As with the <em>hello_world_handler</em> from before, we can return anything from a handler, that implements <em>IntoResponse</em>, which axum's <code>Json&lt;T&gt;(T)</code> is doing.</p>
<p>We just echo the payload inside the handler and add an <code>id</code> to it, which a normal server would do, after creating a ressource in a database to confirm creation of the new ressource.</p>
<h2 id="task"><a class="header" href="#task">Task</a></h2>
<p>You have seen above, how you can echo a Json. Let's do it - but with a form this time!
Write a handler, that accepts a form instead of a Json - and just echoes the data you have provided. You can go to
<code>snippets/axum/extraction</code>. There is already the boilerplate for you at hand.</p>
<ul>
<li>Go ahead and try to implement the following function</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: You have to implement this one :)
async fn my_form(Form(form): Form&lt;MyForm&gt;) -&gt; impl IntoResponse {
    todo!()
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>If you think you implemented it correctly, you can run <code>cargo test</code>.</li>
</ul>
<p><em>Hint</em>: You can also provide form data with curl with the following command:</p>
<pre><code class="language-sh">curl -X POST -d &quot;name=SomeName&amp;age=44&quot; localhost:3000/submit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>In this chapter we look how you add state to your webserver. Then we'll look how you
can access this state in your handlers.</p>
<h2 id="how-to-add-state"><a class="header" href="#how-to-add-state">How to add state</a></h2>
<p>What's a webserver worth, if it cannot handle state?
In this example we will fill a <code>HashMap</code> of people (from the previous chapter)
and add a query to fetch all - and fetch one. That will be your task.</p>
<p>To add state in axum we have to options:</p>
<ul>
<li><code>State</code>: it's type safe - will fail at compile time</li>
<li><code>Extension</code>: Not typesafe - i.e will fail at runtime</li>
</ul>
<p>We will use State here. To add a state, you can call the <code>.with_state()</code> at the
end of your <code>Router Builder</code>. We will just put a HashMap for learning reason (It's wrapped in an <code>Arc&lt;Mutex&lt;_&gt;&gt;</code>, so we can share it between threads). Usually you would
give a handle to a database pool - which the handler then can use to
make queries and insertions to a database.</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let persons: HashMap&lt;String, Person&gt; = HashMap::new();
    let in_memory_db = Arc::new(Mutex::new(persons));

    let router = Router::new()
        .route(&quot;/persons&quot;, post(add_person_handler))
        .with_state(in_memory_db);

    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:3000&quot;).await.unwrap();

    axum::serve(listener, router).await.unwrap();
}</code></pre></pre>
<h2 id="how-to-access-and-mutate-state"><a class="header" href="#how-to-access-and-mutate-state">How to access (and mutate) state</a></h2>
<p>With axum's extraction logic, you can also extract <code>State</code> in the same way in the handler like a <code>Json</code> extractor.
Now you can really add persons in the <code>add_person_handler</code>, like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn add_person_handler(
    State(db): State&lt;InMemoryDb&gt;, // &lt;-- State extractor - here we get the state
    Json(person_to_add): Json&lt;PersonToAdd&gt;,
) -&gt; impl IntoResponse {
    let mut db_lock = db.lock().await; // &lt;-- Get the mutex lock

    let uuid = Uuid::new_v4();
    let person = Person {
        uuid: uuid.to_string(),
        name: person_to_add.name,
    };
    db_lock.insert(uuid.to_string(), person.clone()); // &lt;-- Insert the person

    Json(person)
}
<span class="boring">}</span></code></pre></pre>
<p>Let's write a small handler to receive all of our current person - but this time as a small challenge for you ;).</p>
<h2 id="your-task"><a class="header" href="#your-task">Your Task</a></h2>
<ul>
<li>Go into the project <code>snippets/axum/state</code> and open your IDE of choice there.</li>
<li>Write a handler, that returns a list of <code>Person</code> as Json, when you call <code>GET /persons</code>. Of course the list
will only be filled up, if you posted some persons</li>
<li>We already gave you a small starter here:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: This is your task ;)
pub async fn get_all_persons_handler(State(db): State&lt;InMemoryDb&gt;) -&gt; impl IntoResponse {
    todo!()
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>run <code>cargo test</code> to verify you implemented the handler correctly</li>
</ul>
<p><em>Hint</em>: You can also test your webserver afterwards with <code>cargo run</code>. To add persons with this curl command:</p>
<pre><code class="language-sh">curl --header &quot;Content-Type: application/json&quot; --request POST --data '{&quot;name&quot;:&quot;Hans&quot;}' http://localhost:3000/persons
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-dependency-injectioninversion-with-axum"><a class="header" href="#optional-dependency-injectioninversion-with-axum">(Optional) Dependency Injection/Inversion with Axum</a></h1>
<p>As of now we added our state directly into our web project. For greater projects
it usually makes sense to abstract details away. In the end it should not matter,
how your state is stored. It might be an SQL like database, a file, or something else.</p>
<p>In the end you are only interested in &quot;storing&quot; your state. But how - is a matter of detail,
that we are now going to abstract away.</p>
<p>Currently, we have this dependency tree (left) - but we want to invert the dependency (right):</p>
<p><img src="axum/assets/dependency_inversion.png" alt="img.png" /></p>
<p>Here you do not have to code anything - we just wanted you to show, how a production style
rust webserver could look like. The code for it is in <code>snippets/injection</code>. You can run the unit tests with
<code>cargo test</code>, or run the webserver by <code>cargo run</code>.</p>
<h2 id="turning-around-dependencies"><a class="header" href="#turning-around-dependencies">Turning around dependencies</a></h2>
<p>Our goal would be to turn around the dependency, such that our business logic
does not depend on the implementation of the storage. Rather it should depend on an interface.
The implementation then should depend on that same interface as well.
This way, we can decouple
our business logic from the implementation of our storage.</p>
<p>In Rust you usually achieve this behaviour with Traits.</p>
<p>First we define our trait, that's our interface layer between the storage implementation and anything else (e.g. our business logic):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Repository {
    async fn add_user(&amp;mut self, user: &amp;UserToCreate) -&gt; User;
    async fn remove_user(&amp;mut self, id: i64) -&gt; Option&lt;User&gt;;
    async fn get_users(&amp;self) -&gt; Vec&lt;User&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Next, we can then implement a struct, that wraps our details and implements the above trait.
We implement an <code>SqliteAdapter</code> - wrapping an <code>SqlitePool</code> and implementing above interface.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct SqliteAdapter {
    pool: SqlitePool,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl Repository for SqliteAdapter {
    async fn add_user(&amp;mut self, user: &amp;UserToCreate) -&gt; User {..}
    async fn remove_user(&amp;mut self, id: i64) -&gt; Option&lt;User&gt; {..}
    async fn get_users(&amp;self) -&gt; Vec&lt;User&gt; {..}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-do-you-now-use-this-trait-in-axum-handlers"><a class="header" href="#how-do-you-now-use-this-trait-in-axum-handlers">How do you now use this trait in axum handlers?</a></h2>
<p>To make use of our new trait, we have to make them known to our handlers (where we
usually have our business logic). Instead of using a struct inside our <code>State</code> extractor, we can
use the trait with static dispatch (generics):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn get_users&lt;T: Repository&gt;(State(repo): State&lt;T&gt;) -&gt; impl IntoResponse {
    Json(repo.get_users().await)
}
<span class="boring">}</span></code></pre></pre>
<p>Now our inner logic (turning things into a Json), does not depend on the implementation, but rather on the interface,
that promises to return a list of users.</p>
<p>As axum heavily depends on generics, it's a bit harder to tell the compiler, that we want to make
use of this trait. Structs, that implement our trait, also must implement more traits
to be used in a &quot;generic&quot; router.</p>
<p>To be correct they must implement: <code>Clone + Send + Sync + 'static</code>. For example our
<code>Arc&lt;Mutex&lt;HashMap&lt;_,_&gt;&gt;&gt;</code> would implement all of these above. For our SqliteAdapter
<code>Send + Sync</code> is implement be the wrapped <code>SqlitePool</code>. This is why have to declare our
<code>SqliteAdapter</code> to by <code>Clone</code>. Our structures are automatically <code>'static</code>, as we will create
them in the beginning of our program (see chapters below) - and we guarantee, they outlive all places where they are used.</p>
<p>TL;DR: Our router (that defines the routes, and uses our handlers) needs more guarantees to be generic
We have to make more guarantees, so we can use the interface we defined. A generic router looks like this now:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn routes&lt;T: Repository + Clone + Send + Sync + 'static&gt;() -&gt; Router&lt;T&gt; {
    Router::new()
        .route(&quot;/users&quot;, get(get_users::&lt;T&gt;).post(add_user::&lt;T&gt;))
        .route(&quot;/users/:id&quot;, delete(remove_user::&lt;T&gt;))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-and-where-do-you-dependency-inject-the-implementation"><a class="header" href="#how-and-where-do-you-dependency-inject-the-implementation">How (and where) do you dependency inject the implementation?</a></h2>
<p>After we have a trait layer between our storage implemention, the next question is,
where do we now <em>inject</em> our <code>SqliteAdapter</code> into our program?</p>
<p>The answer is rather simple. We just give our <code>with_state(...)</code> method in the router builder
our <code>SqliteAdapter</code>. The compiler is happy, as <code>SqliteAdapter</code> meets all guarantees, we promised
our compiler.</p>
<p>We inject like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pool = Sqlitepool:new()...;// create an sqlitepool from sqlx
let adapter = SqliteAdapter::new(pool).await;
let router = Router::new().merge(user::routes()).with_state(adapter);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="askama"><a class="header" href="#askama">Askama</a></h1>
<p>Askama is a popular Rust templating engine inspired by Jinja2 and Twig.
It focuses on simplicity, safety, and efficiency by compiling templates into pure Rust code at build time.
In this chapter, we will explore what makes Askama unique and learn how to use it effectively.</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;title&gt;{{ title|upper }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello, {{ user.name }}!&lt;/h1&gt;
    
    {% if user.is_admin %}
        &lt;p&gt;Welcome, Admin!&lt;/p&gt;
    {% else %}
        &lt;p&gt;Welcome, User!&lt;/p&gt;
    {% endif %}
    
    &lt;ul&gt;
        {% for role in user.roles %}
            &lt;li&gt;{{ role }}&lt;/li&gt;
        {% endfor %}
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<center>example askama snippet displaying filter, conditional rendering and a loop</center>
<h2 id="template-engines"><a class="header" href="#template-engines">Template Engines</a></h2>
<p>Template engines are tools used to generate dynamic content (mostly, but not exclusively HTML).
They generate the content by combining static templates with runtime data.
Historically, they evolved out of server side includes and PHP, 
where embedding logic directly in HTML became a standard practice for creating dynamic web pages. 
Over time, modern template engines emerged with cleaner syntax, 
better safety features, and more structured approaches to templating.
They provide various properties that contribute to their usability and functionality:</p>
<h3 id="safety-through-auto-escaping"><a class="header" href="#safety-through-auto-escaping">Safety Through Auto-Escaping</a></h3>
<p>Modern template engines like Askama ensure safety by escaping special characters in user input. 
This prevents common security issues like Cross-Site Scripting (XSS) in web applications. 
By default, Askama escapes potentially unsafe characters when rendering HTML templates.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User {
    name: &quot;Alice&quot;,
    bio: &quot;&lt;script&gt;alert('Hacked!')&lt;/script&gt;&quot;,
};
<span class="boring">}</span></code></pre></pre>
<p>Scripts are by default escaped so they are not executed. <code>{{ bio }}</code> will be rendered like this:</p>
<pre><code>&amp;lt;script&amp;gt;alert('Hacked!')&amp;lt;/script&amp;gt;
</code></pre>
<h3 id="minimal-set-of-control-syntax"><a class="header" href="#minimal-set-of-control-syntax">Minimal Set of Control Syntax</a></h3>
<p>Template Engines provide a concise and minimal syntax for common control structures like <em>loops</em>, <em>conditionals</em>, and <em>filters</em>.
This reduces boilerplate and improves template readability.</p>
<h3 id="simplicity-and-composability"><a class="header" href="#simplicity-and-composability">Simplicity and Composability</a></h3>
<p>Templates are meant to be simple and composable. 
Template Engines typically support features like <em>includes</em> and <em>inheritance</em>, 
which make it easy to break large templates into smaller, reusable pieces.</p>
<h2 id="properties-of-askama"><a class="header" href="#properties-of-askama">Properties of Askama</a></h2>
<h3 id="compiled-templates"><a class="header" href="#compiled-templates">Compiled Templates</a></h3>
<p>Askama compiles templates into Rust code at build time.
This approach ensures type safety, better performance, and early detection of syntax errors. 
Unlike interpreted engines like Tera, Askama doesn’t evaluate templates at runtime, 
making it faster and less error-prone at runtime.
Tera, on the other hand, guarantees a more rapid development cycle especially for more complex projects, 
exactly because it can get around the compilation step.</p>
<h3 id="inspiration-from-jinja2-and-twig"><a class="header" href="#inspiration-from-jinja2-and-twig">Inspiration from Jinja2 and Twig</a></h3>
<p>Askama’s syntax is heavily inspired by Jinja2 (Python) and Twig (PHP).
Developers familiar with these engines will find Askama’s syntax intuitive and easy to adopt.
The same is true for Tera.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Feature</strong></th><th><strong>Askama</strong></th><th><strong>Jinja2</strong></th></tr></thead><tbody>
<tr><td><strong>Variable interpolation</strong></td><td><code>Hello, {{ name }}!</code></td><td><code>Hello, {{ name }}!</code></td></tr>
<tr><td><strong>Conditionals</strong></td><td><code>{% if is_logged_in %}Welcome!{% else %}Please log in.{% endif %}</code></td><td><code>{% if is_logged_in %}Welcome!{% else %}Please log in.{% endif %}</code></td></tr>
<tr><td><strong>Loops</strong></td><td><code>{% for item in items %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}</code></td><td><code>{% for item in items %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}</code></td></tr>
<tr><td><strong>Includes</strong></td><td><code>{% include &quot;header.html&quot; %}</code></td><td><code>{% include &quot;header.html&quot; %}</code></td></tr>
<tr><td><strong>Template inheritance</strong></td><td><code>{% extends &quot;base.html&quot; %}{% block content %}Hello{% endblock %}</code></td><td><code>{% extends &quot;base.html&quot; %}{% block content %}Hello{% endblock %}</code></td></tr>
<tr><td><strong>Filters</strong></td><td><code>{{ name\|upper }}</code></td><td><code>{{ name \| upper }}</code></td></tr>
<tr><td><strong>Macros</strong></td><td><code>{% macro greet(name) %}Hello, {{ name }}!{% endmacro %}</code></td><td><code>{% macro greet(name) %}Hello, {{ name }}!{% endmacro %}</code></td></tr>
<tr><td><strong>Match-like structures</strong></td><td><code>{% match status %}{% when &quot;success&quot; %}OK{% else %}Error{% endmatch %}</code></td><td></td></tr>
<tr><td><strong>Rust-specific syntax</strong></td><td><code>{% if let Some(value) = optional %}{{ value }}{% endif %}</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="how-to"><a class="header" href="#how-to">How-to</a></h2>
<p>This section provides a step-by-step guide to using Askama in your projects.</p>
<h3 id="include-askama-in-your-app"><a class="header" href="#include-askama-in-your-app">Include Askama in Your App</a></h3>
<p>Add Askama to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
askama = &quot;0.12&quot;
</code></pre>
<h3 id="locate-templates-in-your-project"><a class="header" href="#locate-templates-in-your-project">Locate Templates in Your project</a></h3>
<p>Templates are stored in a templates directory by convention. 
File extensions like <code>.html</code> or <code>.txt</code> indicate the template's format.</p>
<p>For example, <code>templates/hello.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello, {{ name }}!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome, {{ name }}!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="use-variables--render-templates"><a class="header" href="#use-variables--render-templates">Use Variables / Render Templates</a></h3>
<p>Pass data to templates using Rust structs:</p>
<pre><pre class="playground"><code class="language-rust">use askama::Template;

#[derive(Template)]
#[template(path = &quot;hello.html&quot;)]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}

fn main() {
    let hello = HelloTemplate { name: &quot;Alice&quot; };
    println!(&quot;{}&quot;, hello.render().unwrap());
}</code></pre></pre>
<h3 id="architect-with-template-inheritance--blocks"><a class="header" href="#architect-with-template-inheritance--blocks">Architect with Template Inheritance / Blocks</a></h3>
<p>Template inheritance allows defining base layouts and extending them with specific blocks.
For example:</p>
<pre><code class="language-html">&lt;!-- templates/base.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{% block title %}Default Title{% endblock %}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {% block content %}{% endblock %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- templates/home.html --&gt;
{% extends &quot;base.html&quot; %}

{% block title %}Home{% endblock %}

{% block content %}
&lt;h1&gt;Welcome to the home page!&lt;/h1&gt;
{% endblock %}
</code></pre>
<h3 id="compose-with-includes"><a class="header" href="#compose-with-includes">Compose with Includes</a></h3>
<p>Use <code>{% include %}</code> to embed reusable components:</p>
<pre><code class="language-html">&lt;!-- templates/base.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{% block title %}Default Title{% endblock %}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {% include &quot;header.html&quot; %}
    {% block content %}{% endblock %}
    {% include &quot;footer.html&quot; %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="use-loops-and-conditionals"><a class="header" href="#use-loops-and-conditionals">Use Loops and Conditionals</a></h3>
<p>Render dynamic content using loops and conditionals:</p>
<pre><code class="language-html">&lt;ul&gt;
{% for item in items %}
    &lt;li&gt;{{ item }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;

{% if condition %}
    &lt;p&gt;Condition is true!&lt;/p&gt;
{% else %}
    &lt;p&gt;Condition is false!&lt;/p&gt;
{% endif %}
</code></pre>
<p>Rust-Specific if let and match
Askama supports Rust's <code>if let</code> and <code>match</code> expressions for more complex logic:</p>
<pre><code class="language-html">{% if let Some(value) = optional %}
    &lt;p&gt;Value: {{ value }}&lt;/p&gt;
{% else %}
    &lt;p&gt;No value found.&lt;/p&gt;
{% endif %}

{% match status %}
    {% when &quot;success&quot; %}&lt;p&gt;Success!&lt;/p&gt;
    {% when &quot;error&quot; %}&lt;p&gt;Error occurred.&lt;/p&gt;
    {% else %}&lt;p&gt;Unknown status.&lt;/p&gt;
{% endmatch %}
</code></pre>
<h3 id="use-filters"><a class="header" href="#use-filters">Use Filters</a></h3>
<p>Filters process variables for display:</p>
<pre><code class="language-html">&lt;p&gt;{{ message|upper }}&lt;/p&gt;
</code></pre>
<p><em>Note that the pipe symbol must not be surrounded by spaces; otherwise, it will be interpreted as the BitOr operator.</em></p>
<h3 id="register-your-own-filters"><a class="header" href="#register-your-own-filters">Register Your Own Filters</a></h3>
<p>Custom filters can be registered in Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod filters {
    pub fn reverse(s: &amp;str) -&gt; askama::Result&lt;String&gt; {
        Ok(s.chars().rev().collect())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="full-example-integrating-askama-with-axum"><a class="header" href="#full-example-integrating-askama-with-axum">Full Example: Integrating Askama with Axum</a></h2>
<h3 id="step-1-template-definition"><a class="header" href="#step-1-template-definition">Step 1: Template Definition</a></h3>
<p>Create an Askama template file, <code>templates/hello.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello, {{ user.name }}!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Define the corresponding Rust struct for the template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use askama::Template;

#[derive(Template)]
#[template(path = &quot;hello.html&quot;)]
pub struct HelloTemplate&lt;'a&gt; {
    pub title: &amp;'a str,
    pub user: User&lt;'a&gt;,
}

pub struct User&lt;'a&gt; {
    pub name: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-axum-handler-with-impl-intoresponse"><a class="header" href="#step-2-axum-handler-with-impl-intoresponse">Step 2: Axum Handler with impl IntoResponse</a></h3>
<p>Set up an Axum handler that renders the Askama template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    response::{IntoResponse, Response},
    routing::get,
    Router,
};
use askama::Template; // Bring in the Template trait for rendering.
use crate::{HelloTemplate, User};

async fn hello_handler() -&gt; impl IntoResponse {
    let user = User { name: &quot;Alice&quot; };
    let template = HelloTemplate {
        title: &quot;Hello Page&quot;,
        user,
    };

    match template.render() {
        Ok(html) =&gt; Response::builder()
            .header(&quot;Content-Type&quot;, &quot;text/html&quot;)
            .body(html)
            .unwrap(),
        Err(err) =&gt; {
            eprintln!(&quot;Template rendering error: {}&quot;, err);
            Response::builder()
                .status(500)
                .body(&quot;Internal Server Error&quot;.into())
                .unwrap()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-3-set-up-axum-application"><a class="header" href="#step-3-set-up-axum-application">Step 3: Set Up Axum Application</a></h3>
<p>Create an Axum app and route the handler:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let app = Router::new().route(&quot;/&quot;, get(hello_handler));
    axum::Server::bind(&amp;&quot;127.0.0.1:3000&quot;.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="why-htmx"><a class="header" href="#why-htmx">Why htmx?</a></h1>
<h2 id="you-are-doing-rest-wrong"><a class="header" href="#you-are-doing-rest-wrong">You are doing REST wrong</a></h2>
<blockquote>
<p>I am getting frustrated by the number of people calling any HTTP-based interface a REST API.
Today’s example is the SocialSite REST API. That is RPC.
It screams RPC.
There is so much coupling on display that it should be given an X rating.
What needs to be done to make the REST architectural style clear on the notion that hypertext is a constraint? In other words, if the engine of application state (and hence the API) is not being driven by hypertext, then it cannot be RESTful and cannot be a REST API.
Period.
Is there some broken manual somewhere that needs to be fixed?</p>
</blockquote>
<p>–Roy Fielding, Creator of the term REST</p>
<h2 id="users-do-not-understand-json"><a class="header" href="#users-do-not-understand-json">Users do not understand Json</a></h2>
<p>No, but the browser can convert: </p>
<pre><code class="language-html">&lt;button hx-post=&quot;/clicked&quot;
    hx-trigger=&quot;click&quot;
    hx-target=&quot;#parent-div&quot;
    hx-swap=&quot;outerHTML&quot;
&gt;
    Click Me!
&lt;/button&gt;
</code></pre>
<p>to a Button</p>
<h2 id="attributes-over-javascript"><a class="header" href="#attributes-over-javascript">Attributes over javascript</a></h2>
<p>With javascript:</p>
<pre><code class="language-html">&lt;button id=&quot;my-button&quot; on-click=&quot;clicked()&quot;&gt;
    Click Me!
&lt;/button&gt;
&lt;script&gt;
function clicked(){
  const request = new XMLHttpRequest();

  xhr.onreadystatechange = () =&gt; {
    if (xhr.readyState === 4) {
       const element = document.getElementById(&quot;parent-div&quot;);
       element.outerHtml = xhr.response
    }
  };

  request.open('POST', &quot;/clicked&quot;);
  request.send(null);
}

&lt;/script&gt;
</code></pre>
<p>With Htmx:</p>
<pre><code class="language-html">&lt;button hx-post=&quot;/clicked&quot;
    hx-trigger=&quot;click&quot;
    hx-target=&quot;#parent-div&quot;
    hx-swap=&quot;outerHTML&quot;
&gt;
    Click Me!
&lt;/button&gt;
</code></pre>
<p>This was a simple example, but we already see how concise Htmx can be.</p>
<p>Now infinite scroll:</p>
<p>With javascript:</p>
<pre><code class="language-html">&lt;tr 
  &lt;td&gt;Agent Smith&lt;/td&gt;
  &lt;td&gt;void29@null.org&lt;/td&gt;
  &lt;td&gt;55F49448C0&lt;/td&gt;
&lt;/tr&gt;

&lt;script&gt;
//... yeah not going to do that
&lt;/script&gt;
</code></pre>
<p>With Htmx:</p>
<pre><code class="language-html">&lt;tr hx-get=&quot;/contacts/?page=2&quot;
    hx-trigger=&quot;revealed&quot;
    hx-swap=&quot;afterend&quot;&gt;
  &lt;td&gt;Agent Smith&lt;/td&gt;
  &lt;td&gt;void29@null.org&lt;/td&gt;
  &lt;td&gt;55F49448C0&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="htmx-samples"><a class="header" href="#htmx-samples">HTMX samples</a></h1>
<h3 id="simple-button"><a class="header" href="#simple-button">Simple Button</a></h3>
<pre><code class="language-html">    &lt;h1&gt;HTMX Example&lt;/h1&gt;
    &lt;button hx-get=&quot;/message&quot; hx-target=&quot;#message&quot;&gt;Click me!&lt;/button&gt;
    &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="form"><a class="header" href="#form">Form</a></h3>
<pre><code class="language-html"> &lt;h1&gt;HTMX Example&lt;/h1&gt;
    &lt;form
    hx-post=&quot;/message&quot; 
    hx-target=&quot;#message&quot;
    &gt;
        
    &lt;input type=&quot;text&quot; name=&quot;message&quot; placeholder=&quot;Enter your message&quot;&gt;

    &lt;button type=&quot;submit&quot; &gt;Click me!&lt;/button&gt;
    &lt;/form&gt;
    
    &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="composition"><a class="header" href="#composition">Composition</a></h3>
<pre><code class="language-html">&lt;h1&gt;Example&lt;/h1&gt;
&lt;div hx-get=&quot;/component1&quot; hx-trigger=&quot;load delay:2s&quot;&gt;
   
&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;h1&gt;HTMX Component&lt;/h1&gt;
&lt;div&gt;
    
   &lt;p&gt;Component 1&lt;/p&gt;
   
   &lt;button hx-get=&quot;/message&quot;  hx-target=&quot;#message&quot; &gt;
       Get message
   &lt;/button&gt;

&lt;div id=&quot;message&quot;&gt;&lt;/div&gt;

&lt;/div&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
